<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      事件机制 | Cruyun&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Cruyun">
    
    

    <meta name="description" content="事件监听事件监听有以下三种方法。

HTML内联属性类似&amp;lt;button onclick=&amp;quot;alert(&amp;#39;你点击了这个按钮&amp;#39;);&amp;quot;&amp;gt;点击这个按钮&amp;lt;/button&amp;gt;的方式，这种方式会使 JS 与 HTML 高度耦合，不利于开发和维护，不推荐使用。

DOM属性绑定（事件处理器属性）使用DOM元素的onXXX属性设置，简单易懂，兼容性好。确定是">
<meta property="og:type" content="article">
<meta property="og:title" content="事件机制 | Cruyun's Blog">
<meta property="og:url" content="https://Cruyun.github.io/2018/11/14/事件机制/index.html">
<meta property="og:site_name" content="Cruyun's Blog">
<meta property="og:description" content="事件监听事件监听有以下三种方法。

HTML内联属性类似&amp;lt;button onclick=&amp;quot;alert(&amp;#39;你点击了这个按钮&amp;#39;);&amp;quot;&amp;gt;点击这个按钮&amp;lt;/button&amp;gt;的方式，这种方式会使 JS 与 HTML 高度耦合，不利于开发和维护，不推荐使用。

DOM属性绑定（事件处理器属性）使用DOM元素的onXXX属性设置，简单易懂，兼容性好。确定是">
<meta property="og:updated_time" content="2018-11-14T09:20:21.760Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="事件机制 | Cruyun's Blog">
<meta name="twitter:description" content="事件监听事件监听有以下三种方法。

HTML内联属性类似&amp;lt;button onclick=&amp;quot;alert(&amp;#39;你点击了这个按钮&amp;#39;);&amp;quot;&amp;gt;点击这个按钮&amp;lt;/button&amp;gt;的方式，这种方式会使 JS 与 HTML 高度耦合，不利于开发和维护，不推荐使用。

DOM属性绑定（事件处理器属性）使用DOM元素的onXXX属性设置，简单易懂，兼容性好。确定是">
    
    
    
      <link rel="icon" type="image/x-icon" href="/huno/favicon.ico">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for Cruyun&#39;s Blog"><img src="https://avatars3.githubusercontent.com/u/24372759?s=460&amp;v=4" width="80" alt="Cruyun&#39;s Blog logo" class="panel-cover__logo logo" /></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Cruyun&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          Talk is cheap, show you my code
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/Cruyun" title="Huno on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>




        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">事件机制</h1>

    

    <div class="post-meta">
      <time datetime="2018-11-14" class="post-meta__date date">2018-11-14</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Browser/">Browser</a>, <a class="tags-link" href="/tags/DOM/">DOM</a>, <a class="tags-link" href="/tags/JavaScript/">JavaScript</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>事件监听有以下三种方法。</p>
<ol>
<li><p>HTML内联属性<br>类似<code>&lt;button onclick=&quot;alert(&#39;你点击了这个按钮&#39;);&quot;&gt;点击这个按钮&lt;/button&gt;</code>的方式，这种方式会使 JS 与 HTML 高度耦合，不利于开发和维护，不推荐使用。</p>
</li>
<li><p>DOM属性绑定（事件处理器属性）<br>使用DOM元素的onXXX属性设置，简单易懂，兼容性好。确定是只能绑定一个处理函数。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var btn = document.querySelector(&apos;button&apos;);</div><div class="line">btn.onclick = function() &#123;...&#125;</div></pre></td></tr></table></figure>
<p>一些事件非常通用，几乎在任何地方都可以用（比如 onclick 几乎可以用在几乎每一个元素上），然而另一些元素就只能在特定场景下使用，比如我们只能在 video 元素上使用 onplay 。</p>
<ol>
<li>事件监听器</li>
</ol>
<p>使用事件监听函数 <code>element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;);</code>，在 element 这个对象上面添加一个事件监听器，当监听到有 事件发生的时候，调用 这个<strong>回调函数</strong>。至于 这个参数，表示该事件监听是在<strong>“捕获”</strong>阶段中监听（设置为 <strong>true</strong>）还是在“<strong>冒泡</strong>”阶段中监听（设置为 <strong>false</strong>）。 如果没有指定， useCapture 默认为 false 。 </p>
<blockquote>
<p>注意: 对于事件目标上的事件监听器来说，事件会处于“目标阶段”，而不是冒泡阶段或者捕获阶段。在目标阶段的事件会触发该元素（即事件目标）上的所有监听器，而不在乎这个监听器到底在注册时useCapture 参数值是true还是false。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var btn = document.querySelector(&apos;button&apos;);</div><div class="line"></div><div class="line">function bgChange() &#123;</div><div class="line">  var rndCol = &apos;rgb(&apos; + random(255) + &apos;,&apos; + random(255) + &apos;,&apos; + random(255) + &apos;)&apos;;</div><div class="line">  document.body.style.backgroundColor = rndCol;</div><div class="line">&#125;   </div><div class="line"></div><div class="line">btn.addEventListener(&apos;click&apos;, bgChange);</div></pre></td></tr></table></figure>
<p><code>removeEventListener()</code>方法移除事件监听器。例如<code>btn.removeEventListener(&#39;click&#39;, bgChange);</code></p>
<p>另外，给同一个监听器注册多个处理器，如果使用事件处理器属性，后面的处理器会覆盖前面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myElement.onclick = functionA;</div><div class="line">myElement.onclick = functionB;</div></pre></td></tr></table></figure>
<p>而下面这种方法可以正常工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myElement.addEventListener(&apos;click&apos;, functionA);</div><div class="line">myElement.addEventListener(&apos;click&apos;, functionB);</div></pre></td></tr></table></figure>
<p> IE9之前的版本中无法使用标准的 addEventListener 函数，而是使用自家的 attachEvent，具体用法：element.attachEvent(<event-name>, <callback>);</callback></event-name></p>
<p>它只支持监听在冒泡阶段触发的事件，所以为了统一，在使用标准事件监听函数的时候，第三参数传递 false。</p>
<h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><ol>
<li><strong>事件捕获</strong>阶段: window 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li><strong>处于目标</strong>阶段: 传播到事件触发处时触发注册的事件</li>
<li><strong>事件冒泡</strong>阶段: 从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li>
</ol>
<p>不同的浏览器对此有着不同的实现，IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在</p>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 以下会先打印冒泡然后是捕获</div><div class="line">node.addEventListener(&apos;click&apos;,(event) =&gt;&#123;</div><div class="line">	console.log(&apos;冒泡&apos;)</div><div class="line">&#125;,false);</div><div class="line">node.addEventListener(&apos;click&apos;,(event) =&gt;&#123;</div><div class="line">	console.log(&apos;捕获 &apos;)</div><div class="line">&#125;,true)</div></pre></td></tr></table></figure>
<h2 id="事件捕获-vs-事件冒泡"><a href="#事件捕获-vs-事件冒泡" class="headerlink" title="事件捕获 vs 事件冒泡"></a>事件捕获 vs 事件冒泡</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p>
<p>在现代浏览器中，默认情况下，所有事件处理程序都在<strong>冒泡阶段</strong>进行注册<br>当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。 </p>
<p>在捕获阶段：</p>
<p><strong> 浏览器检查元素的最外层祖先，是否在捕获阶段中注册了一个事件处理程序，如果是，则运行它。
</strong> 然后，它移动到最外层祖先中的下一个元素，并执行相同的操作，然后是下一个元素，依此类推，直到到达实际点击的元素。</p>
<p>在冒泡阶段，恰恰相反:</p>
<p><strong> 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个事件处理程序，如果是，则运行它
</strong> 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达最外层祖先元素。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;s1&quot;&gt;s1</div><div class="line"> &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123; </div><div class="line">  console.log(&quot;s1 冒泡事件&quot;); &#125;,false);</div><div class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123; </div><div class="line">  console.log(&quot;s2 冒泡事件&quot;);&#125;,false);</div><div class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123; </div><div class="line">  console.log(&quot;s1 捕获事件&quot;);&#125;,true);</div><div class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123;</div><div class="line">  console.log(&quot;s2 捕获事件&quot;);&#125;,true);</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">/** 点击 s1</div><div class="line">s1 冒泡事件</div><div class="line">s1 捕获事件</div><div class="line">**/</div><div class="line"></div><div class="line">/** 点击s2</div><div class="line">s1 捕获事件</div><div class="line">s2 冒泡事件</div><div class="line">s2 捕获事件</div><div class="line">s1 冒泡事件</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>点击 s2，click 事件从 document  -&gt; html -&gt; body -&gt; s1 -&gt; s2 捕获前进，输出“s1 捕获事件”后到目的结点 s2，s2上先后注册了冒泡和捕获，于是按注册顺序输出 “ s2 冒泡事件” 、“s2 捕获事件”。下面进入冒泡阶段，从s2 -&gt; s1 -&gt; body -&gt; html -&gt; document 冒泡前进，在s1发现冒泡事件，于是输出“s1 冒泡事件”</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如event，evt或简单的e。 这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息。</p>
<p>事件对象会作为第一个参数，传递给我们的回调函数。我们可以使用下面代码，在浏览器中打印出这个事件对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementsByTagName(&apos;button&apos;);</div><div class="line">    btn[0].addEventListener(&apos;click&apos;, function(event) &#123;</div><div class="line">        console.log(event);</div><div class="line">    &#125;, false);</div></pre></td></tr></table></figure>
<p>比较常用的几个属性和方法：</p>
<ul>
<li>type(string)：事件的名称，比如 “click”。</li>
<li>target(node)：事件要触发的目标节点。</li>
<li>currentTarget(node)： 它就指向正在处理事件的元素：这恰是我们需要的。很不幸的是微软模型中并没有相似的属性, 你也可以使用”this”关键字。事件属性也提供了一个值可供访问:event.currentTarget。</li>
<li>bubbles (boolean):：表明该事件是否是在冒泡阶段触发的。该属性为只读属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function goInput(e) &#123;</div><div class="line">  if (!e.bubbles) &#123;</div><div class="line">    passItOn(e);</div><div class="line">  &#125; else &#123;</div><div class="line">    doOutput(e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>preventDefault (function)</strong>：这个方法可以禁止一切默认的行为，例如点击 a 标签时，会打开一个新页面，如果为 a 标签监听事件 click 同时调用该方法，则不会打开新页面。</li>
<li>cancelable (boolean)： 这个属性表明该事件是否可以通过调用 event.preventDefault 方法来禁用默认行为。</li>
<li>eventPhase (number)：这个属性的数字表示当前事件触发在什么阶段。<br>0: 事件目前没有发生<br>1: 事件目前处于捕获阶段<br>2: 事件到达目标节点<br>3: 事件处于冒泡阶段</li>
<li>pageX 和 pageY (number)： 这两个属性表示触发事件时，鼠标相对于页面的坐标。</li>
<li>isTrusted (boolean)： 表明该事件是浏览器触发（用户真实操作触发），还是 JavaScript 代码触发的。</li>
</ul>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件绑定后，检测顺序就会从被绑定的DOM<strong>下滑</strong>到触发的元素，再冒泡会绑定的DOM上。也就是说，如果你监听了一个DOM节点，那也就等于你监听了其所有的后代节点。</p>
<p>代理的意思就是只监听父节点的事件触发，以来代理对其后代节点的监听，而你需要做的只是通过currentTarget属性得到触发元素并作出回应。</p>
<p>使用事件代理意味着你可以节省大量重复的事件监听，以减少浏览器资源消耗。还有一个好处就是让HTML独立起来，比如之后还有要加子元素的需求，也不需要再为其单独加事件监听了</p>
<p>下面举个例子 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;color-list&quot;&gt;</div><div class="line"> &lt;li&gt;red&lt;/li&gt;</div><div class="line"> &lt;li&gt;yellow&lt;/li&gt;</div><div class="line"> &lt;li&gt;blue&lt;/li&gt;</div><div class="line"> &lt;li&gt;green&lt;/li&gt;</div><div class="line"> &lt;li&gt;black&lt;/li&gt;</div><div class="line"> &lt;li&gt;white&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>如果点击页面中的li元素，然后输出li当中的颜色，我们通常会这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line"> var color_list = document.getElementById(&apos;color-list&apos;);</div><div class="line"> var colors = color_list.getElementsByTagName(&apos;li&apos;);</div><div class="line"> for(var i=0;i&lt;colors.length;i++)&#123;</div><div class="line"> colors[i].addEventListener(&apos;click&apos;,showColor,false); &#125;;</div><div class="line"> function showColor(e)&#123;</div><div class="line"> var x = e.target;</div><div class="line"> console.log(&quot;The color is &quot; + x.innerHTML);</div><div class="line"> &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>利用事件流的特性，我们只绑定一个事件处理函数也可以完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  var color_list =document.getElementById(&apos;color-list&apos;);</div><div class="line">  color_list.addEventListener(&apos;click&apos;,showColor,false);</div><div class="line">  function showColor(e)&#123;</div><div class="line">  var x = e.target;</div><div class="line">  if(x.nodeName.toLowerCase() === &apos;li&apos;)&#123;</div><div class="line">  console.log(&apos;The color is &apos; + x.innerHTML);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="阻止默认行为：stopPropagation-function-、stopImmediatePropagation"><a href="#阻止默认行为：stopPropagation-function-、stopImmediatePropagation" class="headerlink" title="阻止默认行为：stopPropagation (function)、stopImmediatePropagation"></a>阻止默认行为：stopPropagation (function)、stopImmediatePropagation</h2><ul>
<li><strong>stopPropagation (function)</strong>： 很多时候，我们触发某个元素，会顺带触发出它父级身上的事件，这有时候是我们不想要的，大多数我们想要的还是事件相互独立。所以我们可以选择阻止<strong>事件冒泡</strong>，使用event.stopPropagation().</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(&apos;click&apos;, function (event) &#123;</div><div class="line">  event.stopPropagation();</div><div class="line">  console.log(1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">element.addEventListener(&apos;click&apos;, function(event) &#123;</div><div class="line">  // 会触发</div><div class="line">  console.log(2);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><strong>stopImmediatePropagation (function)</strong>： 与 stopPropagation 类似，就是阻止触发其他监听函数。但是与 stopPropagation 不同的是，它更加 “强力”，阻止<strong>除了目标之外的事件</strong>触发，甚至阻止针对同一个目标节点的相同事件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(&apos;click&apos;, function (event) &#123;</div><div class="line">  // 会触发</div><div class="line">  console.log(‘改方法内的可以执行’);</div><div class="line">  event.stopImmediatePropagation();</div><div class="line">  // 会触发</div><div class="line">  console.log(1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">element.addEventListener(&apos;click&apos;, function(event) &#123;</div><div class="line">  // 不会被触发</div><div class="line">  console.log(2);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://leohxj.gitbooks.io/front-end-database/javascript-basic/events.html" target="_blank" rel="external">事件机制 | 前端工程师手册</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events" target="_blank" rel="external">事件介绍 - 学习 Web 开发 | MDN</a></li>
<li><a href="http://www.imooc.com/article/17035" target="_blank" rel="external">详解JS中的事件机制</a></li>
</ul>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
